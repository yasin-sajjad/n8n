import type { BaseMessage } from '@langchain/core/messages';
import { isAIMessage, ToolMessage, HumanMessage } from '@langchain/core/messages';
import type { StructuredTool } from '@langchain/core/tools';
import { isCommand, isGraphInterrupt, END } from '@langchain/langgraph';

import { isBaseMessage } from '../types/langchain';
import type { WorkflowMetadata } from '../types/tools';
import type { WorkflowOperation } from '../types/workflow';

interface CommandUpdate {
	messages?: BaseMessage[];
	workflowOperations?: WorkflowOperation[];
	templateIds?: number[];
	cachedTemplates?: WorkflowMetadata[];
	bestPractices?: string;
	expressionExamples?: Record<string, string>;
}

/** Check that an optional field, if present, has the expected type */
function hasValidOptionalField(
	obj: Record<string, unknown>,
	key: string,
	type: 'array' | 'string' | 'object',
): boolean {
	if (!(key in obj) || obj[key] === undefined) return true;
	if (type === 'array') return Array.isArray(obj[key]);
	if (type === 'object') return typeof obj[key] === 'object' && !Array.isArray(obj[key]);
	return typeof obj[key] === type;
}

/**
 * Type guard to check if an object has the shape of CommandUpdate
 */
function isCommandUpdate(value: unknown): value is CommandUpdate {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	const obj = value as Record<string, unknown>;
	return (
		hasValidOptionalField(obj, 'messages', 'array') &&
		hasValidOptionalField(obj, 'workflowOperations', 'array') &&
		hasValidOptionalField(obj, 'templateIds', 'array') &&
		hasValidOptionalField(obj, 'cachedTemplates', 'array') &&
		hasValidOptionalField(obj, 'bestPractices', 'string') &&
		hasValidOptionalField(obj, 'expressionExamples', 'object')
	);
}

/**
 * Collect state updates from tool results (Command or BaseMessage).
 */
function collectToolResults(toolResults: unknown[]): {
	messages?: BaseMessage[];
	workflowOperations?: WorkflowOperation[] | null;
	templateIds?: number[];
	cachedTemplates?: WorkflowMetadata[];
	bestPractices?: string;
	expressionExamples?: Record<string, string>;
} {
	const messages: BaseMessage[] = [];
	const operations: WorkflowOperation[] = [];
	const templateIds: number[] = [];
	const cachedTemplates: WorkflowMetadata[] = [];
	let bestPractices: string | undefined;
	let expressionExamples: Record<string, string> | undefined;

	for (const result of toolResults) {
		if (isCommand(result)) {
			if (isCommandUpdate(result.update)) {
				if (result.update.messages) {
					messages.push(...result.update.messages);
				}
				if (result.update.workflowOperations) {
					operations.push(...result.update.workflowOperations);
				}
				if (result.update.templateIds) {
					templateIds.push(...result.update.templateIds);
				}
				if (result.update.cachedTemplates) {
					cachedTemplates.push(...result.update.cachedTemplates);
				}
				if (result.update.bestPractices) {
					bestPractices = result.update.bestPractices;
				}
				if (result.update.expressionExamples) {
					expressionExamples = expressionExamples
						? { ...expressionExamples, ...result.update.expressionExamples }
						: result.update.expressionExamples;
				}
			}
		} else if (isBaseMessage(result)) {
			messages.push(result);
		}
	}

	const stateUpdate: {
		messages?: BaseMessage[];
		workflowOperations?: WorkflowOperation[] | null;
		templateIds?: number[];
		cachedTemplates?: WorkflowMetadata[];
		bestPractices?: string;
		expressionExamples?: Record<string, string>;
	} = {};

	if (messages.length > 0) stateUpdate.messages = messages;
	if (operations.length > 0) stateUpdate.workflowOperations = operations;
	if (templateIds.length > 0) stateUpdate.templateIds = templateIds;
	if (cachedTemplates.length > 0) stateUpdate.cachedTemplates = cachedTemplates;
	if (bestPractices) stateUpdate.bestPractices = bestPractices;
	if (expressionExamples) stateUpdate.expressionExamples = expressionExamples;

	return stateUpdate;
}

/**
 * Execute tools in a subgraph node
 *
 * Adapts the executeToolsInParallel pattern for subgraph use.
 * Executes all tool calls from the last AI message in parallel.
 *
 * Tools that call interrupt() (like submit_questions) are handled naturally:
 * - On initial run: interrupt() throws GraphInterrupt, Promise.all rejects, graph pauses
 * - On resume: interrupt() returns the user's answers, all tools complete normally
 *
 * @param state - Subgraph state with messages array
 * @param toolMap - Map of tool name to tool instance
 * @returns State update with messages and optional operations
 */
export async function executeSubgraphTools(
	state: { messages: BaseMessage[] },
	toolMap: Map<string, StructuredTool>,
): Promise<{
	messages?: BaseMessage[];
	workflowOperations?: WorkflowOperation[] | null;
	templateIds?: number[];
	cachedTemplates?: WorkflowMetadata[];
	bestPractices?: string;
	expressionExamples?: Record<string, string>;
}> {
	const lastMessage = state.messages[state.messages.length - 1];

	if (!lastMessage || !isAIMessage(lastMessage) || !lastMessage.tool_calls?.length) {
		return {};
	}

	// Execute all tools in parallel
	const toolResults = await Promise.all(
		lastMessage.tool_calls.map(async (toolCall) => {
			const tool = toolMap.get(toolCall.name);
			if (!tool) {
				return new ToolMessage({
					content: `Tool ${toolCall.name} not found`,
					tool_call_id: toolCall.id ?? '',
				});
			}

			try {
				const result: unknown = await tool.invoke(toolCall.args ?? {}, {
					toolCall: {
						id: toolCall.id,
						name: toolCall.name,
						args: toolCall.args ?? {},
					},
				});
				// Result can be a Command (with update) or a BaseMessage
				// We return it as-is and handle the type in the loop below
				return result;
			} catch (error) {
				// Let GraphInterrupt propagate - tools like submit_questions use interrupt() for HITL
				if (isGraphInterrupt(error)) {
					throw error;
				}
				return new ToolMessage({
					content: `Tool failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
					tool_call_id: toolCall.id ?? '',
				});
			}
		}),
	);

	return collectToolResults(toolResults);
}

/**
 * Extract user request from parent state messages
 * Gets the LAST HumanMessage (most recent user request), not the first
 */
export function extractUserRequest(messages: BaseMessage[], defaultValue = ''): string {
	// Get the LAST HumanMessage (most recent user request for iteration support)
	// Skip resume messages to avoid treating plan decisions/answers as new requests.
	const humanMessages = messages.filter((m) => m instanceof HumanMessage);
	const lastNonResumeMessage = [...humanMessages]
		.reverse()
		.find((msg) => msg.additional_kwargs?.resumeData === undefined);
	const lastUserMessage = lastNonResumeMessage ?? humanMessages[humanMessages.length - 1];
	return typeof lastUserMessage?.content === 'string' ? lastUserMessage.content : defaultValue;
}

/**
 * Standard shouldContinue logic for tool-based subgraphs
 * Checks presence of tool calls to determine if we should continue to tools node.
 */
export function createStandardShouldContinue() {
	return (state: { messages: BaseMessage[] }) => {
		const lastMessage = state.messages[state.messages.length - 1];
		const hasToolCalls =
			lastMessage &&
			'tool_calls' in lastMessage &&
			Array.isArray(lastMessage.tool_calls) &&
			lastMessage.tool_calls.length > 0;

		return hasToolCalls ? 'tools' : END;
	};
}
