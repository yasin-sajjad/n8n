/**
 * Security validators for the AST interpreter.
 * Defines allowed SDK functions, methods, and detects dangerous patterns.
 */
import type { Node, CallExpression, MemberExpression } from 'estree';
import { SecurityError, UnsupportedNodeError } from './errors';

/**
 * Allowlist of SDK functions that can be called at the top level.
 */
export const ALLOWED_SDK_FUNCTIONS = new Set([
	// Core workflow builders
	'workflow',
	'node',
	'trigger',
	'sticky',
	'placeholder',
	'newCredential',

	// Control flow
	'ifElse',
	'switchCase',
	'merge',
	'splitInBatches',
	'nextBatch',

	// AI/LangChain subnodes
	'languageModel',
	'memory',
	'tool',
	'outputParser',
	'embedding',
	'embeddings',
	'vectorStore',
	'retriever',
	'documentLoader',
	'textSplitter',
	'reranker',

	// Utility
	'fromAi', // NEW: replaces ($) => $.fromAi() pattern
]);

/**
 * Allowlist of method names that can be called on SDK objects.
 */
export const ALLOWED_METHODS = new Set([
	// Workflow builder methods
	'add',
	'then',
	'to',

	// Node builder methods
	'input',
	'output',
	'onError',

	// Control flow methods
	'onTrue',
	'onFalse',
	'onCase',
	'onEachBatch',
	'onDone',

	// Internal methods
	'toJSON',
	'validate',
]);

/**
 * Dangerous global identifiers that should be rejected.
 */
const DANGEROUS_GLOBALS = new Set([
	'eval',
	'Function',
	'require',
	'import',
	'process',
	'global',
	'globalThis',
	'window',
	'document',
	'setTimeout',
	'setInterval',
	'setImmediate',
	'clearTimeout',
	'clearInterval',
	'clearImmediate',
	'__dirname',
	'__filename',
	'module',
	'exports',
	'Buffer',
	'Reflect',
	'Proxy',
]);

/**
 * Node types that are allowed in SDK code.
 */
const ALLOWED_NODE_TYPES = new Set([
	// Program structure
	'Program',

	// Declarations
	'VariableDeclaration',
	'VariableDeclarator',

	// Statements
	'ExpressionStatement',
	'ReturnStatement',

	// Expressions
	'CallExpression',
	'MemberExpression',
	'ObjectExpression',
	'ArrayExpression',
	'Identifier',
	'Literal',
	'TemplateLiteral',
	'TemplateElement',
	'SpreadElement',
	'Property',

	// Operators (for simple expressions like array access)
	'UnaryExpression',
	'BinaryExpression',
	'LogicalExpression',
	'ConditionalExpression',
]);

/**
 * Node types that are explicitly forbidden (for better error messages).
 */
const FORBIDDEN_NODE_TYPES: Record<string, string> = {
	ArrowFunctionExpression:
		'Arrow functions are not allowed. Use fromAi() directly instead of ($) => $.fromAi()',
	FunctionExpression: 'Function expressions are not allowed in SDK code',
	FunctionDeclaration: 'Function declarations are not allowed in SDK code',
	ClassDeclaration: 'Class declarations are not allowed in SDK code',
	ClassExpression: 'Class expressions are not allowed in SDK code',
	ForStatement: 'For loops are not allowed in SDK code',
	ForInStatement: 'For-in loops are not allowed in SDK code',
	ForOfStatement: 'For-of loops are not allowed in SDK code',
	WhileStatement: 'While loops are not allowed in SDK code',
	DoWhileStatement: 'Do-while loops are not allowed in SDK code',
	TryStatement: 'Try-catch is not allowed in SDK code',
	ThrowStatement: 'Throw statements are not allowed in SDK code',
	WithStatement: 'With statements are not allowed in SDK code',
	AssignmentExpression: 'Assignments are not allowed. Use const declarations only.',
	UpdateExpression: 'Update expressions (++, --) are not allowed in SDK code',
	NewExpression: 'new expressions are not allowed. Use SDK factory functions instead.',
	ImportDeclaration: 'Import declarations are not allowed in SDK code',
	ImportExpression: 'Dynamic imports are not allowed in SDK code',
	AwaitExpression: 'Await expressions are not allowed in SDK code',
	YieldExpression: 'Yield expressions are not allowed in SDK code',
};

/**
 * Check if a node type is allowed.
 * @throws UnsupportedNodeError if the node type is not allowed
 */
export function validateNodeType(node: Node, sourceCode: string): void {
	if (FORBIDDEN_NODE_TYPES[node.type]) {
		throw new UnsupportedNodeError(
			`${node.type}: ${FORBIDDEN_NODE_TYPES[node.type]}`,
			node.loc ?? undefined,
			sourceCode,
		);
	}

	if (!ALLOWED_NODE_TYPES.has(node.type)) {
		throw new UnsupportedNodeError(node.type, node.loc ?? undefined, sourceCode);
	}
}

/**
 * Check if an identifier is a dangerous global.
 * @throws SecurityError if the identifier is dangerous
 */
export function validateIdentifier(
	name: string,
	_allowedVariables: Set<string>,
	node: Node,
	sourceCode: string,
): void {
	if (DANGEROUS_GLOBALS.has(name)) {
		throw new SecurityError(
			`Access to '${name}' is not allowed`,
			node.loc ?? undefined,
			sourceCode,
		);
	}
}

/**
 * Validate a function call expression.
 * @throws SecurityError if the call is dangerous
 */
export function validateCallExpression(node: CallExpression, sourceCode: string): void {
	// Check for dangerous patterns like eval("...")
	if (node.callee.type === 'Identifier') {
		const name = node.callee.name;
		if (name === 'eval') {
			throw new SecurityError('eval()', node.loc ?? undefined, sourceCode);
		}
		if (name === 'Function') {
			throw new SecurityError('Function()', node.loc ?? undefined, sourceCode);
		}
		if (name === 'require') {
			throw new SecurityError('require()', node.loc ?? undefined, sourceCode);
		}
	}

	// Check for dangerous patterns like global.constructor.constructor
	if (node.callee.type === 'MemberExpression') {
		const memberExpr = node.callee;
		if (memberExpr.property.type === 'Identifier' && memberExpr.property.name === 'constructor') {
			throw new SecurityError('constructor access', node.loc ?? undefined, sourceCode);
		}
	}
}

/**
 * Validate a member expression.
 * @throws SecurityError if the access is dangerous
 */
export function validateMemberExpression(node: MemberExpression, sourceCode: string): void {
	// Reject dynamic property access obj[expr] (computed access)
	// Allow obj.property (non-computed)
	if (node.computed) {
		// Allow simple literal keys like obj["key"] or obj[0]
		if (node.property.type !== 'Literal') {
			throw new SecurityError(
				'Dynamic property access is not allowed. Use static property names.',
				node.loc ?? undefined,
				sourceCode,
			);
		}
	}

	// Check for dangerous property names
	if (node.property.type === 'Identifier') {
		const propName = node.property.name;
		if (propName === '__proto__' || propName === 'prototype' || propName === 'constructor') {
			throw new SecurityError(
				`Access to '${propName}' is not allowed`,
				node.loc ?? undefined,
				sourceCode,
			);
		}
	}
}

/**
 * Check if an identifier is an allowed SDK function.
 */
export function isAllowedSDKFunction(name: string): boolean {
	return ALLOWED_SDK_FUNCTIONS.has(name);
}

/**
 * Check if a method name is allowed.
 */
export function isAllowedMethod(name: string): boolean {
	return ALLOWED_METHODS.has(name);
}
