import type { User } from '@n8n/db';
import {
	AuthenticatedRequest,
	UserRepository,
	WorkflowRepository,
	ProjectRelationRepository,
	ProjectRepository,
} from '@n8n/db';
import { RestController, Get, Post, Param } from '@n8n/decorators';
import type { Response } from 'express';
import {
	CHAT_TRIGGER_NODE_TYPE,
	FORM_TRIGGER_NODE_TYPE,
	WEBHOOK_NODE_TYPE,
	MANUAL_TRIGGER_NODE_TYPE,
	SCHEDULE_TRIGGER_NODE_TYPE,
	createRunExecutionData,
	jsonStringify,
	type INode,
	type IPinData,
	type IWorkflowExecutionDataProcess,
	type WorkflowExecuteMode,
} from 'n8n-workflow';

import { ActiveExecutions } from '@/active-executions';
import { CredentialsService } from '@/credentials/credentials.service';
import { NotFoundError } from '@/errors/response-errors/not-found.error';
import { WorkflowRunner } from '@/workflow-runner';
import { WorkflowFinderService } from '@/workflows/workflow-finder.service';
import { WorkflowSharingService } from '@/workflows/workflow-sharing.service';

const LLM_API_KEY = process.env.N8N_AGENT_LLM_API_KEY ?? '';
const LLM_BASE_URL = process.env.N8N_AGENT_LLM_BASE_URL ?? 'https://api.anthropic.com';
const LLM_MODEL = process.env.N8N_AGENT_LLM_MODEL ?? 'claude-sonnet-4-5-20250929';
const MAX_ITERATIONS = 10;
const EXECUTION_TIMEOUT_MS = 120_000;

const SUPPORTED_TRIGGERS: Record<string, string> = {
	[MANUAL_TRIGGER_NODE_TYPE]: 'Manual Trigger',
	[WEBHOOK_NODE_TYPE]: 'Webhook Trigger',
	[CHAT_TRIGGER_NODE_TYPE]: 'Chat Trigger',
	[FORM_TRIGGER_NODE_TYPE]: 'Form Trigger',
	[SCHEDULE_TRIGGER_NODE_TYPE]: 'Schedule Trigger',
};

interface LlmMessage {
	role: 'system' | 'user' | 'assistant';
	content: string;
}

interface TaskStep {
	action: string;
	workflowName?: string;
	result?: string;
}

@RestController('/agents')
export class AgentsController {
	constructor(
		private readonly userRepository: UserRepository,
		private readonly workflowRepository: WorkflowRepository,
		private readonly workflowSharingService: WorkflowSharingService,
		private readonly credentialsService: CredentialsService,
		private readonly projectRelationRepository: ProjectRelationRepository,
		private readonly projectRepository: ProjectRepository,
		private readonly workflowFinderService: WorkflowFinderService,
		private readonly workflowRunner: WorkflowRunner,
		private readonly activeExecutions: ActiveExecutions,
	) {}

	@Get('/:agentId/capabilities')
	async getCapabilities(
		_req: AuthenticatedRequest,
		_res: Response,
		@Param('agentId') agentId: string,
	) {
		const agentUser = await this.userRepository.findOne({
			where: { id: agentId },
			relations: ['role'],
		});

		if (!agentUser) {
			throw new NotFoundError(`Agent ${agentId} not found`);
		}

		const workflowIds = await this.workflowSharingService.getSharedWorkflowIds(agentUser, {
			scopes: ['workflow:read'],
		});

		const workflows = workflowIds.length
			? await this.workflowRepository.findByIds(workflowIds, {
					fields: ['id', 'name', 'active'],
				})
			: [];

		const credentials = await this.credentialsService.getMany(agentUser, {
			includeGlobal: false,
		});

		const projectRelations = await this.projectRelationRepository.findAllByUser(agentUser.id);
		const projectIds = projectRelations.map((r) => r.projectId);

		const projects =
			projectIds.length > 0 ? await this.projectRepository.findByIds(projectIds) : [];

		return {
			agentId: agentUser.id,
			agentName: `${agentUser.firstName} ${agentUser.lastName}`.trim(),
			projects: projects.map((p) => ({ id: p.id, name: p.name })),
			workflows: workflows.map((w) => ({
				id: w.id,
				name: w.name,
				active: w.active,
			})),
			credentials: credentials.map((c) => ({
				id: c.id,
				name: c.name,
				type: c.type,
			})),
		};
	}

	@Post('/:agentId/task')
	async dispatchTask(req: AuthenticatedRequest, _res: Response, @Param('agentId') agentId: string) {
		const { prompt } = req.body as { prompt: string };

		const agentUser = await this.userRepository.findOne({
			where: { id: agentId },
			relations: ['role'],
		});

		if (!agentUser) {
			throw new NotFoundError(`Agent ${agentId} not found`);
		}

		if (!LLM_API_KEY) {
			return {
				status: 'error' as const,
				message:
					'N8N_AGENT_LLM_API_KEY not configured. Set the environment variable to enable agent tasks.',
			};
		}

		// Fetch capabilities for LLM context
		const workflowIds = await this.workflowSharingService.getSharedWorkflowIds(agentUser, {
			scopes: ['workflow:read'],
		});
		const workflows = workflowIds.length
			? await this.workflowRepository.findByIds(workflowIds, {
					fields: ['id', 'name', 'active'],
				})
			: [];

		const workflowList = workflows.map((w) => ({
			id: w.id,
			name: w.name,
			active: w.active,
		}));

		const agentName = `${agentUser.firstName} ${agentUser.lastName}`.trim();
		const steps: TaskStep[] = [];

		const systemPrompt = buildSystemPrompt(agentName, workflowList);
		const messages: LlmMessage[] = [
			{ role: 'system', content: systemPrompt },
			{ role: 'user', content: prompt },
		];

		for (let i = 0; i < MAX_ITERATIONS; i++) {
			const llmResponse = await callLlm(messages);
			messages.push({ role: 'assistant', content: llmResponse });

			// Strip markdown code fences if present
			const cleaned = llmResponse
				.replace(/^```(?:json)?\s*/i, '')
				.replace(/\s*```\s*$/, '')
				.trim();

			let parsed: {
				action: string;
				workflowId?: string;
				reasoning?: string;
				summary?: string;
			};
			try {
				parsed = JSON.parse(cleaned);
			} catch {
				return { status: 'completed' as const, summary: llmResponse, steps };
			}

			if (parsed.action === 'complete') {
				return {
					status: 'completed' as const,
					summary: parsed.summary ?? 'Task completed',
					steps,
				};
			}

			if (parsed.action === 'execute_workflow' && parsed.workflowId) {
				const capWorkflow = workflowList.find((w) => w.id === parsed.workflowId);
				const workflowName = capWorkflow?.name ?? parsed.workflowId;

				steps.push({ action: 'execute_workflow', workflowName });

				try {
					const result = await this.runWorkflow(agentUser, parsed.workflowId);
					const observation = `Workflow "${workflowName}" executed. Result: ${jsonStringify(result).slice(0, 2000)}`;
					steps[steps.length - 1].result = result.success ? 'success' : 'failed';
					messages.push({ role: 'user', content: `Observation: ${observation}` });
				} catch (error) {
					const errorMsg = error instanceof Error ? error.message : String(error);
					steps[steps.length - 1].result = 'error';
					messages.push({
						role: 'user',
						content: `Observation: Workflow execution failed: ${errorMsg}`,
					});
				}
			} else {
				messages.push({
					role: 'user',
					content: 'Observation: Unknown action. Use "execute_workflow" or "complete".',
				});
			}
		}

		return { status: 'completed' as const, summary: 'Reached maximum iterations', steps };
	}

	private async runWorkflow(
		user: User,
		workflowId: string,
	): Promise<{ success: boolean; executionId: string; data?: unknown }> {
		const workflow = await this.workflowFinderService.findWorkflowForUser(
			workflowId,
			user,
			['workflow:execute'],
			{ includeActiveVersion: true },
		);

		if (!workflow) {
			throw new Error(`Workflow ${workflowId} not found or agent lacks permission`);
		}

		const nodes = workflow.activeVersion?.nodes ?? workflow.nodes ?? [];
		const connections = workflow.activeVersion?.connections ?? workflow.connections ?? {};

		const triggerNode = findSupportedTrigger(nodes);
		if (!triggerNode) {
			throw new Error(
				`Workflow has no supported trigger. Supported: ${Object.values(SUPPORTED_TRIGGERS).join(', ')}`,
			);
		}

		const pinData = buildPinData(triggerNode);

		const runData: IWorkflowExecutionDataProcess = {
			executionMode: getExecutionMode(triggerNode),
			workflowData: { ...workflow, nodes, connections },
			userId: user.id,
			startNodes: [{ name: triggerNode.name, sourceData: null }],
			pinData,
			executionData: createRunExecutionData({
				startData: {},
				resultData: { pinData, runData: {} },
				executionData: {
					contextData: {},
					metadata: {},
					nodeExecutionStack: [
						{
							node: triggerNode,
							data: { main: [pinData[triggerNode.name]] },
							source: null,
						},
					],
					waitingExecution: {},
					waitingExecutionSource: {},
				},
			}),
		};

		const executionId = await this.workflowRunner.run(runData);

		const resultPromise = this.activeExecutions.getPostExecutePromise(executionId);
		const timeoutPromise = new Promise<never>((_, reject) => {
			setTimeout(() => reject(new Error('Workflow execution timed out')), EXECUTION_TIMEOUT_MS);
		});

		const data = await Promise.race([resultPromise, timeoutPromise]);

		if (data === undefined) {
			throw new Error('Workflow did not return any data');
		}

		const success = data.status !== 'error' && !data.data.resultData?.error;

		return { success, executionId, data: data.data.resultData };
	}
}

function findSupportedTrigger(nodes: INode[]): INode | undefined {
	const supported = Object.keys(SUPPORTED_TRIGGERS);
	return nodes.find((node) => supported.includes(node.type) && !node.disabled);
}

function getExecutionMode(node: INode): WorkflowExecuteMode {
	switch (node.type) {
		case WEBHOOK_NODE_TYPE:
			return 'webhook';
		case CHAT_TRIGGER_NODE_TYPE:
			return 'chat';
		case MANUAL_TRIGGER_NODE_TYPE:
			return 'manual';
		default:
			return 'trigger';
	}
}

function buildPinData(node: INode): IPinData {
	switch (node.type) {
		case MANUAL_TRIGGER_NODE_TYPE:
			return {
				[node.name]: [{ json: { triggeredByAgent: true, timestamp: new Date().toISOString() } }],
			};
		case WEBHOOK_NODE_TYPE:
			return {
				[node.name]: [{ json: { headers: {}, query: {}, body: {} } }],
			};
		case CHAT_TRIGGER_NODE_TYPE:
			return {
				[node.name]: [
					{
						json: {
							sessionId: `agent-${Date.now()}`,
							action: 'sendMessage',
							chatInput: 'Triggered by agent',
						},
					},
				],
			};
		case FORM_TRIGGER_NODE_TYPE:
			return {
				[node.name]: [
					{
						json: {
							submittedAt: new Date().toISOString(),
							formMode: 'agent',
						},
					},
				],
			};
		case SCHEDULE_TRIGGER_NODE_TYPE:
			return {
				[node.name]: [
					{
						json: {
							timestamp: new Date().toISOString(),
							triggeredByAgent: true,
						},
					},
				],
			};
		default:
			return {};
	}
}

function buildSystemPrompt(
	agentName: string,
	workflows: Array<{ id: string; name: string; active: boolean }>,
): string {
	const workflowList = workflows
		.map((w) => `- ${w.name} (id: ${w.id}, active: ${w.active})`)
		.join('\n');

	return `You are ${agentName}, an autonomous AI agent in an n8n workflow automation system.

You have access to these workflows:
${workflowList || '(none)'}

RULES:
- Respond with exactly ONE JSON object per message. No markdown, no explanation, no code fences.
- After each action, you will receive an Observation with the result. Wait for it before deciding your next action.
- Do NOT batch multiple actions. One action per response, then wait.

To execute a workflow:
{"action": "execute_workflow", "workflowId": "<id>", "reasoning": "<why>"}

When the task is complete (after seeing all results):
{"action": "complete", "summary": "<what was accomplished>"}

If asked to run something multiple times, execute it once, wait for the result, then execute again.`;
}

async function callLlm(messages: LlmMessage[]): Promise<string> {
	// Extract system message â€” Anthropic puts it as a top-level param
	const systemMessage = messages.find((m) => m.role === 'system')?.content ?? '';
	const conversationMessages = messages
		.filter((m) => m.role !== 'system')
		.map((m) => ({ role: m.role as 'user' | 'assistant', content: m.content }));

	const response = await fetch(`${LLM_BASE_URL}/v1/messages`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			'x-api-key': LLM_API_KEY,
			'anthropic-version': '2023-06-01',
		},
		body: JSON.stringify({
			model: LLM_MODEL,
			system: systemMessage,
			messages: conversationMessages,
			temperature: 0.2,
			max_tokens: 1024,
		}),
	});

	if (!response.ok) {
		throw new Error(`LLM API returned ${response.status}: ${await response.text()}`);
	}

	const data = (await response.json()) as {
		content: Array<{ type: string; text: string }>;
	};
	return data.content.find((c) => c.type === 'text')?.text ?? '';
}
